"""
Classifies: CHEBI:25029 leukotriene
"""
"""
Classifies: Leukotrienes – any icosanoid from the C20 polyunsaturated fatty acid family generated by leukocytes 
from arachidonic acid. They typically feature a 20‐carbon acyclic chain with 4 double bonds (of which at least 3 are conjugated)
and a carboxyl (or related) moiety.

Improved heuristic:
  1) Molecule must be valid.
  2) Molecule is mostly acyclic (allow at most one ring).
  3) A carboxyl (or deprotonated carboxylate) group must be present.
  4) There must exist at least one contiguous subchain of 20 carbons (or a longer chain containing a continuous 20-carbon segment)
     where a window of 20 atoms shows 3 or 4 C=C bonds, and at least 3 of them are conjugated.
"""
from rdkit import Chem
from rdkit.Chem import rdMolDescriptors

def is_leukotriene(smiles: str):
    """
    Determines if a molecule is a leukotriene derivative using improved heuristics.
    
    Args:
        smiles (str): SMILES string of the molecule.
        
    Returns:
        bool: True if molecule is classified as a leukotriene derivative.
        str: Explanation for the classification decision.
    """
    mol = Chem.MolFromSmiles(smiles)
    if mol is None:
        return False, "Invalid SMILES string"
        
    # Rule 1: Check ring count. Leukotrienes are largely acyclic (allow at most one small ring)
    ring_count = mol.GetRingInfo().NumRings()
    if ring_count > 1:
        return False, f"Too many rings ({ring_count}); leukotrienes are mostly acyclic (at most one small ring allowed)"
        
    # Rule 2: Check for the presence of a carboxyl or carboxylate group.
    # This SMARTS pattern covers carboxylic acids (C(=O)O) and carboxylate anions (C(=O)[O-]), including cases with one H.
    carboxyl_smarts = Chem.MolFromSmarts("C(=O)[O;H1,-1]")
    if not mol.HasSubstructMatch(carboxyl_smarts):
        return False, "No carboxyl (or related) group found; expected in arachidonic acid derivatives"
        
    # Rule 3: Look only at carbon atoms.
    carbon_atoms = [atom for atom in mol.GetAtoms() if atom.GetAtomicNum() == 6]
    if len(carbon_atoms) < 20:
        return False, f"Only {len(carbon_atoms)} carbons present; a C20 subchain is required"
    
    carbon_idxs = [atom.GetIdx() for atom in carbon_atoms]
    
    # Build a graph solely for carbons (edges exist when a bond connects 2 carbons)
    carbon_neighbors = {idx: [] for idx in carbon_idxs}
    for bond in mol.GetBonds():
        a1 = bond.GetBeginAtom()
        a2 = bond.GetEndAtom()
        i = a1.GetIdx()
        j = a2.GetIdx()
        if (i in carbon_neighbors) and (j in carbon_neighbors):
            carbon_neighbors[i].append(j)
            carbon_neighbors[j].append(i)
    
    # We set a maximum DFS depth (e.g., allow paths up to 25 atoms) to allow for windows
    max_depth = 25
    found_valid = False
    valid_explanation = ""
    
    # Helper function: given a list (path) of carbon atom indices (in order along a contiguous chain),
    # slide a window of 20 consecutive atoms and check bond properties.
    def check_windows(path):
        nonlocal found_valid, valid_explanation
        # Only check if path length is at least 20.
        if len(path) < 20:
            return
        # Check every contiguous window of 20 atoms from the path.
        for start in range(0, len(path)-20+1):
            subpath = path[start : start+20]
            dbl_count = 0
            conjugated_count = 0
            # For each consecutive pair in the subpath, count if the bond is double and if it is conjugated.
            valid_window = True
            for i in range(len(subpath)-1):
                bond = mol.GetBondBetweenAtoms(subpath[i], subpath[i+1])
                if bond is None:
                    valid_window = False
                    break
                if bond.GetBondType() == Chem.BondType.DOUBLE:
                    dbl_count += 1
                    if bond.GetIsConjugated():
                        conjugated_count += 1
            if not valid_window:
                continue
            # Heuristic: Accept if there are 3 or 4 double bonds and at least 3 of them are conjugated.
            if dbl_count in [3, 4] and conjugated_count >= 3:
                found_valid = True
                valid_explanation = f"Found a 20-carbon segment with {dbl_count} C=C bonds ({conjugated_count} conjugated)"
                return
    
    # DFS to search through carbon-only graph.
    def dfs(path, visited):
        nonlocal found_valid
        if found_valid:
            return
        
        # If the current path has length >= 20 check all contiguous windows.
        if len(path) >= 20:
            check_windows(path)
            if found_valid:
                return
        
        # Do not extend search beyond the maximum allowed depth.
        if len(path) >= max_depth:
            return
        
        current = path[-1]
        for nbr in carbon_neighbors.get(current, []):
            if nbr not in visited:  # only use simple paths
                visited.add(nbr)
                path.append(nbr)
                dfs(path, visited)
                if found_valid:
                    return
                path.pop()
                visited.remove(nbr)
    
    # Start DFS from every carbon atom.
    for start in carbon_idxs:
        dfs([start], set([start]))
        if found_valid:
            break
            
    if not found_valid:
        return False, ("No contiguous 20-carbon segment with the expected unsaturation "
                       "pattern (3-4 C=C bonds with at least 3 conjugated) was found")
    
    # Provide additional properties in the explanation.
    mw = rdMolDescriptors.CalcExactMolWt(mol)
    explanation = (f"Molecule has a contiguous 20-carbon segment where {valid_explanation}, "
                   f"a carboxyl group is present, MW is {mw:.1f} Da, and ring count is {ring_count} "
                   "– consistent with a leukotriene derivative.")
    return True, explanation

# Example usage (uncomment to test):
# example_smiles = "CCCCCC\\C=C/C\\C=C/C=C/C=C/[C@@H]1O[C@H]1CCCC(O)=O"  # leukotriene A4 SMILES
# result, reason = is_leukotriene(example_smiles)
# print(result, reason)