"""
Classifies: CHEBI:25029 leukotriene
"""
"""
Classifies: Leukotrienes – any icosanoid from the C20 polyunsaturated fatty acid family generated by leukocytes 
from arachidonic acid. They typically feature a 20‐carbon mostly linear chain with 4 double bonds 
(of which at least 3 are conjugated) and a terminal carboxyl (or related) group.

Heuristic improvements:
  1) Molecule must be valid, mostly acyclic (at most one ring) and have a carboxyl group.
  2) Identify the carbon atoms that are part of a carboxyl group.
  3) Search through the carbon–only graph to look for a contiguous linear chain (i.e. no branching in the window)
     of 20 carbons.
  4) In each 20‑carbon contiguous window, check that there are 3 or 4 C=C bonds (at least 3 conjugated)
     and that one terminal carbon is part of a carboxyl group.
  5) Optionally check that the molecular weight is in a reasonable window.
  
NOTE: This heuristic approach is not guaranteed to work in every borderline case.
"""
from rdkit import Chem
from rdkit.Chem import rdMolDescriptors

def is_leukotriene(smiles: str):
    """
    Determines if a molecule is a leukotriene derivative using improved heuristics.

    Args:
        smiles (str): SMILES string of the molecule.
        
    Returns:
        bool: True if molecule is classified as a leukotriene derivative.
        str: Explanation for the classification decision.
    """
    mol = Chem.MolFromSmiles(smiles)
    if mol is None:
        return False, "Invalid SMILES string"

    # Rule A: Check overall ring count (allow at most one ring)
    ring_count = mol.GetRingInfo().NumRings()
    if ring_count > 1:
        return False, f"Too many rings ({ring_count}); leukotrienes are mostly acyclic (at most one ring allowed)"

    # Rule B: Check for the presence of a carboxyl or carboxylate group.
    # This SMARTS pattern covers carboxylic acids (C(=O)O) and carboxylate anions (C(=O)[O-]).
    carboxyl_smarts = Chem.MolFromSmarts("C(=O)[O;H1,-1]")
    if not mol.HasSubstructMatch(carboxyl_smarts):
        return False, "No carboxyl (or related) group found; expected in arachidonic acid derivatives"
    
    # Get indices of the carboxyl carbons
    carboxyl_matches = mol.GetSubstructMatches(carboxyl_smarts)
    carboxyl_carbons = set(match[0] for match in carboxyl_matches)

    # Rule C: Basic number of carbons must be at least 20.
    carbon_atoms = [atom for atom in mol.GetAtoms() if atom.GetAtomicNum() == 6]
    if len(carbon_atoms) < 20:
        return False, f"Only {len(carbon_atoms)} carbons present; a C20 subchain is required"
    carbon_idxs = [atom.GetIdx() for atom in carbon_atoms]

    # Build a carbon-only connectivity graph
    carbon_neighbors = {idx: [] for idx in carbon_idxs}
    for bond in mol.GetBonds():
        a1 = bond.GetBeginAtom()
        a2 = bond.GetEndAtom()
        i = a1.GetIdx()
        j = a2.GetIdx()
        if i in carbon_neighbors and j in carbon_neighbors:
            carbon_neighbors[i].append(j)
            carbon_neighbors[j].append(i)

    # A simple molecular weight check -- most leukotrienes fall between ~300 and ~1200 Da.
    mw = rdMolDescriptors.CalcExactMolWt(mol)
    if not (300 <= mw <= 1200):
        return False, f"Molecular weight {mw:.1f} Da out of expected range for leukotrienes"

    # We now search for a contiguous chain (simple path) of carbons.
    # We will DFS over the carbon graph with a maximum depth (to allow for a window of 20 atoms).
    max_depth = 25
    found_valid = False
    valid_explanation = ""

    # Helper function to check a contiguous window in a carbon chain (list of atom indices).
    def check_window(path):
        nonlocal found_valid, valid_explanation
        if len(path) < 20:
            return
        # We consider every contiguous slice of 20 atoms within the current path.
        for start in range(0, len(path) - 20 + 1):
            window = path[start:start+20]
            # Verify that the window is linear in the sense that every consecutive pair is bonded.
            valid_window = True
            dbl_count = 0
            conjugated_count = 0
            for i in range(len(window)-1):
                bond = mol.GetBondBetweenAtoms(window[i], window[i+1])
                if bond is None:
                    valid_window = False
                    break
                if bond.GetBondType() == Chem.BondType.DOUBLE:
                    dbl_count += 1
                    if bond.GetIsConjugated():
                        conjugated_count += 1
            if not valid_window:
                continue
            
            # Check that the window has the expected unsaturation pattern:
            # 3 or 4 double bonds, with at least 3 being conjugated.
            if dbl_count in [3, 4] and conjugated_count >= 3:
                # Further check: one terminal carbon of this window should be the carboxyl carbon.
                if window[0] in carboxyl_carbons or window[-1] in carboxyl_carbons:
                    found_valid = True
                    valid_explanation = (f"Found a contiguous 20-carbon segment with {dbl_count} C=C bonds "
                                         f"({conjugated_count} conjugated) and a carboxyl group at its terminus")
                    return

    # DFS to find potential linear (non-branching) carbon chains.
    def dfs(path, visited):
        nonlocal found_valid
        if found_valid:
            return
        # When the current path is long enough, check every 20-carbon window.
        if len(path) >= 20:
            check_window(path)
            if found_valid:
                return

        if len(path) >= max_depth:
            return

        current = path[-1]
        for nbr in carbon_neighbors.get(current, []):
            if nbr not in visited:
                # To favor a linear (unbranched) chain, we only allow extension if the current path remains 
                # “linear” in the window. That is, for atoms in the current path, their neighbors in the path
                # should be only the immediate previous (or next) ones.
                # (We do not forbid branching in the whole molecule, but we are examining only the window.)
                visited.add(nbr)
                path.append(nbr)
                dfs(path, visited)
                if found_valid:
                    return
                path.pop()
                visited.remove(nbr)

    # Start DFS from each carbon atom.
    for start in carbon_idxs:
        dfs([start], set([start]))
        if found_valid:
            break

    if not found_valid:
        return False, ("No contiguous 20-carbon segment with the expected unsaturation pattern "
                       "(3-4 C=C bonds with at least 3 conjugated, and terminus bearing a carboxyl group) was found")
    
    explanation = (f"Molecule has a contiguous 20-carbon segment meeting the criteria -- {valid_explanation}, "
                   f"MW is {mw:.1f} Da, and ring count is {ring_count} – consistent with a leukotriene derivative.")
    return True, explanation

# Example usage (uncomment to test):
# example_smiles = "CCCCCC\\C=C/C\\C=C/C=C/C=C/[C@@H]1O[C@H]1CCCC(O)=O"  # leukotriene A4 SMILES
# result, reason = is_leukotriene(example_smiles)
# print(result, reason)