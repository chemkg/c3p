"""
Classifies: CHEBI:25029 leukotriene
"""
"""
Classifies: Leukotrienes – any icosanoid stemming from a C20 polyunsaturated fatty acid derivative 
generated by leukocytes from arachidonic acid, typically having four double bonds of which at least three are conjugated.
Improved heuristic: identify a long (≈20-carbon) acyclic chain, check its unsaturation pattern,
verify approximate molecular weight, the presence of a carboxyl (or derivative) group, and limit excess rings.
"""

from rdkit import Chem
from rdkit.Chem import rdMolDescriptors

def get_longest_carbon_chain(mol):
    """
    Returns the longest chain (as a list of atom indices) made exclusively of carbon atoms.
    We use depth-first search over the subgraph of carbons.
    """
    # Build a list of indices of carbon atoms.
    carbon_idxs = [atom.GetIdx() for atom in mol.GetAtoms() if atom.GetAtomicNum() == 6]
    # Build an adjacency dict for carbon atoms only.
    neighbors = {idx: [] for idx in carbon_idxs}
    for bond in mol.GetBonds():
        i = bond.GetBeginAtomIdx()
        j = bond.GetEndAtomIdx()
        if i in neighbors and j in neighbors:
            neighbors[i].append(j)
            neighbors[j].append(i)
    
    longest_chain = []
    
    # DFS function to search all simple paths.
    def dfs(current, visited, path):
        nonlocal longest_chain
        # update longest if necessary
        if len(path) > len(longest_chain):
            longest_chain = path[:]
        for neigh in neighbors[current]:
            if neigh not in visited:
                visited.add(neigh)
                path.append(neigh)
                dfs(neigh, visited, path)
                path.pop()
                visited.remove(neigh)
    
    # Try DFS starting from every carbon.
    for start in carbon_idxs:
        dfs(start, set([start]), [start])
    
    return longest_chain

def is_leukotriene(smiles: str):
    """
    Determines if a molecule is a leukotriene derivative based on its SMILES string.

    The improved heuristic criteria are:
      1. The molecule must be valid and have a reasonable molecular weight (300–500 Da).
      2. The molecule must contain a contiguous carbon chain of at least 20 atoms.
      3. Examining that longest chain, it should have either 4 or, for some derivatives, 3 carbon–carbon double bonds.
         In the chain, at least 3 of these double bonds should be conjugated.
      4. The molecule must have at least one carboxylic acid (or related) group.
      5. The molecule should not be overly “cyclic” (allowing at most one ring; leukotrienes are typically mostly acyclic or contain a single epoxide).

    Args:
        smiles (str): SMILES string of the molecule.

    Returns:
        bool: True if molecule is classified as a leukotriene derivative, False otherwise.
        str: Explanation for the decision.
    """
    mol = Chem.MolFromSmiles(smiles)
    if mol is None:
        return False, "Invalid SMILES string"
    
    # Check molecular weight (typical leukotrienes are roughly 300–500 Da)
    mw = rdMolDescriptors.CalcExactMolWt(mol)
    if not (300 <= mw <= 500):
        return False, f"Molecular weight ({mw:.1f} Da) is outside expected range (300–500 Da) for leukotrienes"
    
    # Count rings; leukotrienes are typically acyclic or have one small ring (e.g. an epoxide).
    ring_count = mol.GetRingInfo().NumRings()
    if ring_count > 1:
        return False, f"Too many rings ({ring_count}); leukotrienes are mostly acyclic (at most one small ring allowed)"
    
    # Check for a carboxyl group (or similar) using a SMARTS pattern.
    # This SMARTS matches carboxylic acids or deprotonated carboxylates.
    carboxyl_smarts = Chem.MolFromSmarts("C(=O)[O;H1,-1]")
    if not mol.HasSubstructMatch(carboxyl_smarts):
        return False, "No carboxyl (or related) group found; expected in arachidonic acid derivatives"
    
    # Get longest carbon chain in the molecule
    chain = get_longest_carbon_chain(mol)
    if len(chain) < 20:
        return False, f"Longest contiguous carbon chain has length {len(chain)}; a C20 chain is required"
    
    # Count carbon–carbon double bonds along the chain.
    dbl_count = 0
    conjugated_count = 0
    for i in range(len(chain)-1):
        a = chain[i]
        b = chain[i+1]
        bond = mol.GetBondBetweenAtoms(a, b)
        # Ensure the bond exists and is between carbons (should be, by selection of chain)
        if bond is not None and bond.GetBondType() == Chem.BondType.DOUBLE:
            dbl_count += 1
            if bond.GetIsConjugated():
                conjugated_count += 1

    # Accept chains that have either exactly 4 or (for some derivative variants) 3 double bonds,
    # but require that at least 3 of the double bonds (if any) are conjugated.
    if dbl_count not in [3, 4]:
        return False, f"Found {dbl_count} carbon–carbon double bonds on the longest chain; expected 3 or 4 in a leukotriene derivative"
    if conjugated_count < 3:
        return False, f"Only {conjugated_count} conjugated double bonds were detected on the longest chain; at least 3 are required"
    
    return True, ("Molecule has a contiguous C20+ carbon chain with an unsaturation pattern "
                  f"of {dbl_count} C=C bonds (with {conjugated_count} conjugated), a carboxyl group, "
                  f"MW of {mw:.1f} Da, and minimal rings—consistent with a leukotriene derivative.")

# Example usage (uncomment to test):
# smiles_example = "CCCCCC\\C=C/C\\C=C/C=C/C=C/[C@@H]1O[C@H]1CCCC(O)=O"  # leukotriene A4 (example)
# result, reason = is_leukotriene(smiles_example)
# print(result, reason)