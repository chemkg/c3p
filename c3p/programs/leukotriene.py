"""
Classifies: CHEBI:25029 leukotriene
"""
"""
Classifies: leukotriene
"""
from rdkit import Chem
from rdkit.Chem import rdMolDescriptors

def is_leukotriene(smiles: str):
    """
    Determines if a molecule is a leukotriene based on its SMILES string.
    A leukotriene is an icosanoid derived from C20 polyunsaturated fatty acids,
    with at least four double bonds (three of which are conjugated),
    possibly containing an epoxide ring, generated by leukocytes from arachidonic acid.
    
    Args:
        smiles (str): SMILES string of the molecule
    
    Returns:
        bool: True if molecule is a leukotriene, False otherwise
        str: Reason for classification
    """
    # Parse SMILES
    mol = Chem.MolFromSmiles(smiles)
    if mol is None:
        return False, "Invalid SMILES string"

    # Remove stereochemistry to simplify matching
    mol2 = Chem.Mol(mol)
    Chem.RemoveStereochemistry(mol2)

    # Count the number of carbon atoms
    c_count = sum(1 for atom in mol2.GetAtoms() if atom.GetAtomicNum() == 6)
    if c_count != 20:
        return False, f"Molecule has {c_count} carbon atoms, expected exactly 20 for leukotriene"

    # Identify double bonds
    double_bonds = [bond for bond in mol2.GetBonds() if bond.GetBondType() == Chem.rdchem.BondType.DOUBLE]
    if len(double_bonds) < 4:
        return False, f"Molecule has {len(double_bonds)} double bonds, expected at least 4 for leukotriene"

    # Check for at least one conjugated triene system (three conjugated double bonds)
    # This SMARTS pattern matches three consecutive double bonds
    conjugated_triene_pattern = Chem.MolFromSmarts("*/[!R]=[!R]/[!R]=[!R]/[!R]=[!R]*")
    conjugated_triene_matches = mol2.GetSubstructMatches(conjugated_triene_pattern)
    if len(conjugated_triene_matches) == 0:
        return False, "No conjugated triene (three conjugated double bonds) found"

    # Allow only epoxide rings; exclude other ring systems
    ring_info = mol2.GetRingInfo()
    if ring_info.NumRings() > 0:
        # Check if all rings are epoxides (3-membered rings with one oxygen)
        for ring in ring_info.AtomRings():
            if len(ring) != 3:
                return False, "Molecule contains rings other than epoxides"
            atoms_in_ring = [mol2.GetAtomWithIdx(idx) for idx in ring]
            o_count = sum(1 for atom in atoms_in_ring if atom.GetAtomicNum() == 8)
            c_count_in_ring = sum(1 for atom in atoms_in_ring if atom.GetAtomicNum() == 6)
            if o_count != 1 or c_count_in_ring != 2:
                return False, "Molecule contains rings other than epoxides"

    # Check for carboxylic acid group (-COOH) at one end
    carboxylic_acid = Chem.MolFromSmarts("C(=O)[O;H1]")
    if not mol2.HasSubstructMatch(carboxylic_acid):
        return False, "No terminal carboxylic acid group found"

    # Optional: Check for presence of cysteine or glutathione conjugates
    # Cysteine conjugate pattern (e.g., for LTC4, LTD4, LTE4)
    cysteine_conjugate = Chem.MolFromSmarts("N[C@@H](CS)[C@@H](C(=O)O)N")
    if mol2.HasSubstructMatch(cysteine_conjugate):
        contains_conjugate = True
    else:
        contains_conjugate = False

    # Check for any hydroxyl groups (-OH), but make it optional
    hydroxyl_group = Chem.MolFromSmarts("[OX2H]")
    has_hydroxyl = mol2.HasSubstructMatch(hydroxyl_group)

    # If molecule meets all criteria, classify as leukotriene
    return True, "Molecule matches criteria for a leukotriene"

__metadata__ = {   'chemical_class': {   'id': 'LEUKOTRIENE',
                              'name': 'leukotriene',
                              'definition': 'Any icosanoid from that family of C20 polyunsaturated fatty acids and their derivatives generated by leukocytes from arachidonic acid, each member having four double bonds of which three are conjugated.',
                              'parents': ['ICOSANOID', 'FATTY_ACID_DERIVATIVE']},
        'config': {   'llm_model_name': 'lbl/claude-sonnet',
                      'f1_threshold': 0.8,
                      'max_attempts': 5,
                      'max_positive_instances': None,
                      'max_positive_to_test': None,
                      'max_negative_to_test': None,
                      'max_positive_in_prompt': 50,
                      'max_negative_in_prompt': 20,
                      'max_instances_in_prompt': 100,
                      'test_proportion': 0.1},
        'message': None,
        'attempt': 2,
        'success': True,
        'best': True,
        'error': '',
        'stdout': None,
        'num_true_positives': None,
        'num_false_positives': None,
        'num_true_negatives': None,
        'num_false_negatives': None,
        'num_negatives': None,
        'precision': None,
        'recall': None,
        'f1': None,
        'accuracy': None}